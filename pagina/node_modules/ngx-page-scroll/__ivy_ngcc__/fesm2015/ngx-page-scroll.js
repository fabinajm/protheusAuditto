import { Directive, EventEmitter, Inject, Input, Optional, Output, NgModule } from '@angular/core';
import { NavigationCancel, NavigationEnd, NavigationError, Router } from '@angular/router';
import { DOCUMENT } from '@angular/common';
import { PageScrollService, NgxPageScrollCoreModule } from 'ngx-page-scroll-core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from 'ngx-page-scroll-core';
import * as ɵngcc2 from '@angular/router';
class NgxPageScrollDirective {
    /**
     * @param {?} pageScrollService
     * @param {?} router
     * @param {?} document
     */
    constructor(pageScrollService, router, document) {
        this.pageScrollService = pageScrollService;
        this.router = router;
        this.pageScrollAdjustHash = false;
        this.pageScrollFinish = new EventEmitter();
        this.document = (/** @type {?} */ (document));
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        // Some inputs changed, reset the pageScrollInstance
        this.pageScrollInstance = undefined;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.pageScrollInstance) {
            this.pageScrollService.stop(this.pageScrollInstance);
        }
    }
    /**
     * @private
     * @return {?}
     */
    generatePageScrollInstance() {
        if (this.pageScrollInstance === undefined || this.pageScrollInstance === null) {
            /** @type {?} */
            const options = {
                document: this.document,
                scrollTarget: this.pageScrollTarget || this.href,
            };
            if (this.pageScroll) {
                options.namespace = this.pageScroll;
            }
            if (this.pageScrollHorizontal !== undefined && this.pageScrollHorizontal !== null) {
                options.verticalScrolling = !this.pageScrollHorizontal;
            }
            if (this.pageScrollOffset !== undefined && this.pageScrollOffset !== null) {
                options.scrollOffset = this.pageScrollOffset;
            }
            if (this.pageScrollInterruptible !== undefined && this.pageScrollInterruptible !== null) {
                options.interruptible = this.pageScrollInterruptible;
            }
            if (this.pageScrollEasing) {
                options.easingLogic = this.pageScrollEasing;
            }
            if (this.pageScrollDuration !== undefined && this.pageScrollDuration !== null) {
                options.duration = this.pageScrollDuration;
            }
            if (this.pageScrollSpeed !== undefined && this.pageScrollSpeed !== null) {
                options.speed = this.pageScrollSpeed;
            }
            if (this.pageScrollFinish) {
                options.scrollFinishListener = this.pageScrollFinish;
            }
            this.pageScrollInstance = this.pageScrollService.create(options);
        }
        return this.pageScrollInstance;
    }
    /**
     * @private
     * @return {?}
     */
    pushRouterState() {
        if (this.pageScrollAdjustHash && typeof this.pageScrollInstance.pageScrollOptions.scrollTarget === 'string'
            && ((/** @type {?} */ (this.pageScrollInstance.pageScrollOptions.scrollTarget))).substr(0, 1) === '#') {
            // "Navigate" to the current route again and this time set the fragment/hash
            this.router.navigate([], {
                fragment: ((/** @type {?} */ (this.pageScrollInstance.pageScrollOptions.scrollTarget))).substr(1),
                preserveQueryParams: true,
            });
        }
    }
    /**
     * @private
     * @return {?}
     */
    scroll() {
        /** @type {?} */
        const pageScrollInstance = this.generatePageScrollInstance();
        this.pushRouterState();
        this.pageScrollService.start(pageScrollInstance);
    }
    /**
     * @param {?} clickEvent
     * @return {?}
     */
    handleClick(clickEvent) {
        if (this.routerLink && this.router !== null && this.router !== undefined) {
            /** @type {?} */
            let urlTree;
            if (typeof this.routerLink === 'string') {
                urlTree = this.router.parseUrl(this.routerLink);
            }
            else {
                urlTree = this.router.createUrlTree(this.routerLink);
            }
            if (!this.router.isActive(urlTree, true)) {
                // We need to navigate their first.
                // Navigation is handled by the routerLink directive
                // so we only need to listen for route change
                /** @type {?} */
                const subscription = (/** @type {?} */ (this.router.events.subscribe((/**
                 * @param {?} routerEvent
                 * @return {?}
                 */
                (routerEvent) => {
                    if (routerEvent instanceof NavigationEnd) {
                        subscription.unsubscribe();
                        // use a timeout to start scrolling as soon as the stack is cleared
                        setTimeout((/**
                         * @return {?}
                         */
                        () => {
                            this.scroll();
                        }), 0);
                    }
                    else if (routerEvent instanceof NavigationError || routerEvent instanceof NavigationCancel) {
                        subscription.unsubscribe();
                    }
                }))));
                return false; // to preventDefault()
            }
        }
        this.scroll();
        return false; // to preventDefault()
    }
}
NgxPageScrollDirective.ɵfac = function NgxPageScrollDirective_Factory(t) { return new (t || NgxPageScrollDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.PageScrollService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Router, 8), ɵngcc0.ɵɵdirectiveInject(DOCUMENT)); };
NgxPageScrollDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgxPageScrollDirective, selectors: [["", "pageScroll", ""]], hostBindings: function NgxPageScrollDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NgxPageScrollDirective_click_HostBindingHandler($event) { return ctx.handleClick($event); });
    } }, inputs: { pageScrollAdjustHash: "pageScrollAdjustHash", routerLink: "routerLink", href: "href", pageScrollTarget: "pageScrollTarget", pageScrollHorizontal: "pageScrollHorizontal", pageScrollOffset: "pageScrollOffset", pageScrollDuration: "pageScrollDuration", pageScrollSpeed: "pageScrollSpeed", pageScrollEasing: "pageScrollEasing", pageScrollInterruptible: "pageScrollInterruptible", pageScroll: "pageScroll" }, outputs: { pageScrollFinish: "pageScrollFinish" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
NgxPageScrollDirective.ctorParameters = () => [
    { type: PageScrollService },
    { type: Router, decorators: [{ type: Optional }] },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
NgxPageScrollDirective.propDecorators = {
    routerLink: [{ type: Input }],
    href: [{ type: Input }],
    pageScrollTarget: [{ type: Input }],
    pageScrollHorizontal: [{ type: Input }],
    pageScrollOffset: [{ type: Input }],
    pageScrollDuration: [{ type: Input }],
    pageScrollSpeed: [{ type: Input }],
    pageScrollEasing: [{ type: Input }],
    pageScrollInterruptible: [{ type: Input }],
    pageScrollAdjustHash: [{ type: Input }],
    pageScroll: [{ type: Input }],
    pageScrollFinish: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxPageScrollDirective, [{
        type: Directive,
        args: [{
                selector: '[pageScroll]',
                host: {
                    '(click)': 'handleClick($event)'
                }
            }]
    }], function () { return [{ type: ɵngcc1.PageScrollService }, { type: ɵngcc2.Router, decorators: [{
                type: Optional
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }]; }, { pageScrollAdjustHash: [{
            type: Input
        }], pageScrollFinish: [{
            type: Output
        }], routerLink: [{
            type: Input
        }], href: [{
            type: Input
        }], pageScrollTarget: [{
            type: Input
        }], pageScrollHorizontal: [{
            type: Input
        }], pageScrollOffset: [{
            type: Input
        }], pageScrollDuration: [{
            type: Input
        }], pageScrollSpeed: [{
            type: Input
        }], pageScrollEasing: [{
            type: Input
        }], pageScrollInterruptible: [{
            type: Input
        }], pageScroll: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxPageScrollModule {
}
NgxPageScrollModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgxPageScrollModule });
NgxPageScrollModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NgxPageScrollModule_Factory(t) { return new (t || NgxPageScrollModule)(); }, imports: [[
            NgxPageScrollCoreModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxPageScrollModule, { declarations: function () { return [NgxPageScrollDirective]; }, imports: function () { return [NgxPageScrollCoreModule]; }, exports: function () { return [NgxPageScrollDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxPageScrollModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    NgxPageScrollDirective,
                ],
                imports: [
                    NgxPageScrollCoreModule,
                ],
                exports: [
                    NgxPageScrollDirective,
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NgxPageScrollModule, NgxPageScrollDirective };

//# sourceMappingURL=ngx-page-scroll.js.map